# Hybrid ORM Architecture: Universal Pattern for Supabase

## Overview

When using **any ORM** with Supabase—whether Drizzle (TypeScript), SQLAlchemy/Alembic (Python), or SQLx (Rust)—you need a **hybrid approach** because ORMs have fundamental limitations that apply across all languages.

**Core Philosophy: "ORM for data modeling, Supabase for data behavior."**

```
┌──────────────────────────────────────────────────────────────┐
│              UNIVERSAL HYBRID ARCHITECTURE                   │
├──────────────────────────────────────────────────────────────┤
│  Language-Specific ORM/Migration Tool                        │
│  ├── Drizzle (TypeScript/Node.js)                           │
│  ├── SQLAlchemy + Alembic (Python)                          │
│  └── SQLx + sqlx-cli (Rust)                                 │
│                    ↓                                         │
│  Generates migrations (table structure only)                 │
│                    ↓                                         │
│  Copy to: supabase/migrations/                               │
│                    ↓                                         │
├──────────────────────────────────────────────────────────────┤
│  Supabase SQL Layer (All Languages Share)                    │
│  ├── Extensions (uuid-ossp, pgvector, pg_net)               │
│  ├── Database Functions (stored procedures)                  │
│  ├── Triggers (audit, updated_at, cascades)                 │
│  └── RLS Policies (row-level security)                       │
└──────────────────────────────────────────────────────────────┘
```

## The Core Problem: ORM Limitations

**NO ORM in ANY language supports creating:**

| Feature | Drizzle | SQLAlchemy | SQLx | Where to Define |
|---------|---------|------------|------|-----------------|
| Tables, columns | ✅ | ✅ | ✅ | ORM schema |
| Constraints (FK, unique) | ✅ | ✅ | ✅ | ORM schema |
| Indexes | ✅ | ✅ | ✅ | ORM schema |
| Schema migrations | ✅ | ✅ | ✅ | ORM migrations |
| **Triggers** | ❌ | ⚠️ Limited | ❌ | `supabase/migrations/` |
| **Stored Functions** | ❌ | ❌ | ❌ | `supabase/migrations/` |
| **RLS Policies** | ❌ | ❌ | ❌ | `supabase/migrations/` |
| **Extensions** | ⚠️ Use only | ⚠️ Use only | ⚠️ Use only | `supabase/migrations/` |

**What ORMs CAN do with unsupported features:**
- Use extensions IF already installed (e.g., pgvector column types)
- Call existing database functions via raw SQL
- Execute raw SQL for anything unsupported

## Multi-Service Architecture

For SaaS with multiple backend services:

```
project-root/
├── services/
│   ├── node-service/
│   │   ├── src/db/
│   │   │   ├── schema.ts          # Drizzle schema
│   │   │   └── migrations/        # Drizzle generated
│   │   └── package.json
│   │
│   ├── python-service/
│   │   ├── app/
│   │   │   ├── models.py          # SQLAlchemy models
│   │   │   └── db.py
│   │   ├── alembic/
│   │   │   └── versions/          # Alembic generated
│   │   └── requirements.txt
│   │
│   └── rust-service/
│       ├── src/
│       │   └── db.rs
│       ├── migrations/            # SQLx manual or sqlx-cli
│       └── Cargo.toml
│
├── supabase/
│   ├── config.toml
│   └── migrations/                # ALL migrations converge here
│       ├── 00000_extensions.sql
│       ├── 00001_tables.sql           # Union from all services
│       ├── 00100_node_tables.sql      # Node-specific tables
│       ├── 00101_node_functions.sql
│       ├── 00200_python_tables.sql    # Python-specific tables
│       ├── 00201_python_functions.sql
│       ├── 00300_rust_tables.sql      # Rust-specific tables
│       ├── 00301_rust_functions.sql
│       └── 00400_shared_rls.sql       # All services use
│
└── .github/workflows/
    └── db-deploy.yml              # Single atomic deploy
```

### Key Principles for Multi-Service

1. **Each service owns its tables** via its native ORM
2. **All migrations merge** into `supabase/migrations/`
3. **Shared behavior** (functions, triggers, RLS) lives in Supabase
4. **Single atomic deploy**: `supabase db push` applies everything
5. **No conflicts**: Numbering system prevents race conditions

---

## Language-Specific Patterns

### TypeScript/Node.js (Drizzle)

**File Structure:**
```
node-service/
├── src/db/
│   ├── schema.ts              # Drizzle table definitions
│   ├── index.ts               # Drizzle client & exports
│   ├── queries/               # Type-safe query functions
│   └── functions/             # Wrappers around DB functions
├── drizzle/
│   └── migrations/            # Generated by Drizzle Kit
└── drizzle.config.ts
```

**Schema Example:**
```typescript
// src/db/schema.ts
import { pgTable, uuid, text, timestamp, numeric, index } from 'drizzle-orm/pg-core';

export const products = pgTable('products', {
  id: uuid('id').primaryKey().defaultRandom(),
  orgId: uuid('org_id').notNull(),
  name: text('name').notNull(),
  price: numeric('price', { precision: 10, scale: 2 }).notNull(),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
}, (table) => ({
  orgIdIdx: index('idx_products_org_id').on(table.orgId),
}));

export type Product = typeof products.$inferSelect;
export type NewProduct = typeof products.$inferInsert;
```

**Generate & Sync:**
```bash
# Generate Drizzle migration
npx drizzle-kit generate

# Copy to Supabase
cp drizzle/migrations/0001_*.sql supabase/migrations/00100_drizzle_products.sql
```

**Calling DB Functions:**
```typescript
import { sql } from 'drizzle-orm';
import { db } from './db';

interface DashboardStats {
  totalOrders: number;
  totalRevenue: number;
}

export async function getDashboardStats(orgId: string): Promise<DashboardStats> {
  const result = await db.execute<DashboardStats>(
    sql`SELECT * FROM get_dashboard_stats(${orgId}::uuid)`
  );
  return result.rows[0];
}
```

---

### Python (SQLAlchemy + Alembic)

**File Structure:**
```
python-service/
├── app/
│   ├── models.py              # SQLAlchemy models
│   ├── db.py                  # Database connection
│   └── functions/             # DB function wrappers
├── alembic/
│   ├── versions/              # Generated migrations
│   ├── env.py
│   └── alembic.ini
└── requirements.txt
```

**Schema Example:**
```python
# app/models.py
from sqlalchemy import Column, String, Numeric, DateTime, ForeignKey, Index
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import declarative_base
from sqlalchemy.sql import func
import uuid

Base = declarative_base()

class Product(Base):
    __tablename__ = 'products'

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    org_id = Column(UUID(as_uuid=True), nullable=False)
    name = Column(String, nullable=False)
    price = Column(Numeric(10, 2), nullable=False)
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())

    __table_args__ = (
        Index('idx_products_org_id', 'org_id'),
    )
```

**Database Connection (async with asyncpg):**
```python
# app/db.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "postgresql+asyncpg://user:pass@host:5432/db"

engine = create_async_engine(DATABASE_URL, echo=True)
async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def get_db():
    async with async_session() as session:
        yield session
```

**Generate & Sync:**
```bash
# Generate Alembic migration
cd python-service/
alembic revision --autogenerate -m "add products table"

# Review the generated migration
cat alembic/versions/*_add_products_table.py

# Export pure SQL for Supabase
alembic upgrade head --sql > /tmp/products.sql
# OR manually copy the upgrade() SQL to:
# supabase/migrations/00200_alembic_products.sql
```

**Calling DB Functions:**
```python
# app/functions/dashboard.py
from sqlalchemy import text
from typing import TypedDict
from app.db import async_session

class DashboardStats(TypedDict):
    total_orders: int
    total_revenue: float

async def get_dashboard_stats(org_id: str) -> DashboardStats:
    async with async_session() as session:
        result = await session.execute(
            text("SELECT * FROM get_dashboard_stats(:org_id::uuid)"),
            {"org_id": org_id}
        )
        row = result.fetchone()
        return {
            "total_orders": row.total_orders,
            "total_revenue": float(row.total_revenue)
        }
```

---

### Rust (SQLx)

**File Structure:**
```
rust-service/
├── src/
│   ├── db/
│   │   ├── mod.rs             # Database module
│   │   ├── models.rs          # Struct definitions
│   │   ├── queries.rs         # Type-safe queries
│   │   └── functions.rs       # DB function wrappers
│   └── main.rs
├── migrations/                # SQLx migrations
│   └── 0001_create_products.sql
├── .env
└── Cargo.toml
```

**Model Example:**
```rust
// src/db/models.rs
use sqlx::FromRow;
use uuid::Uuid;
use rust_decimal::Decimal;
use chrono::{DateTime, Utc};

#[derive(Debug, FromRow)]
pub struct Product {
    pub id: Uuid,
    pub org_id: Uuid,
    pub name: String,
    pub price: Decimal,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug)]
pub struct NewProduct {
    pub org_id: Uuid,
    pub name: String,
    pub price: Decimal,
}
```

**Migration (manual SQL):**
```sql
-- migrations/0001_create_products.sql
CREATE TABLE products (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL,
    name TEXT NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_products_org_id ON products(org_id);
```

**Generate & Sync:**
```bash
# Create SQLx migration
sqlx migrate add create_products

# Run migrations locally (for compile-time checking)
sqlx migrate run

# Copy to Supabase
cp migrations/0001_create_products.sql supabase/migrations/00300_sqlx_products.sql
```

**Calling DB Functions:**
```rust
// src/db/functions.rs
use sqlx::PgPool;
use uuid::Uuid;

#[derive(Debug, sqlx::FromRow)]
pub struct DashboardStats {
    pub total_orders: i64,
    pub total_revenue: rust_decimal::Decimal,
}

pub async fn get_dashboard_stats(pool: &PgPool, org_id: Uuid) -> Result<DashboardStats, sqlx::Error> {
    sqlx::query_as::<_, DashboardStats>(
        "SELECT * FROM get_dashboard_stats($1::uuid)"
    )
    .bind(org_id)
    .fetch_one(pool)
    .await
}
```

---

## Supabase Layer (Shared Across Languages)

### Extensions Migration (00000)

```sql
-- supabase/migrations/00000_extensions.sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS pg_net;
CREATE EXTENSION IF NOT EXISTS vector;  -- For AI/embeddings
```

### Core Functions Migration (00002)

```sql
-- supabase/migrations/00002_core_functions.sql

-- Auto-update updated_at timestamp (all tables use this)
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- Audit logging function
CREATE OR REPLACE FUNCTION public.audit_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.audit_log (user_id, action, table_name, record_id, old_data, new_data)
  VALUES (
    auth.uid(),
    TG_OP,
    TG_TABLE_NAME,
    COALESCE(NEW.id, OLD.id),
    CASE WHEN TG_OP IN ('UPDATE', 'DELETE') THEN row_to_json(OLD)::text END,
    CASE WHEN TG_OP IN ('INSERT', 'UPDATE') THEN row_to_json(NEW)::text END
  );
  RETURN COALESCE(NEW, OLD);
END;
$$;

-- Dashboard stats (called by all services)
CREATE OR REPLACE FUNCTION public.get_dashboard_stats(p_org_id UUID)
RETURNS TABLE (
  total_orders BIGINT,
  total_revenue NUMERIC
)
LANGUAGE sql
STABLE
AS $$
  SELECT
    COUNT(*)::BIGINT as total_orders,
    COALESCE(SUM(total), 0) as total_revenue
  FROM public.orders
  WHERE org_id = p_org_id;
$$;
```

### Core Triggers Migration (00003)

```sql
-- supabase/migrations/00003_core_triggers.sql

-- Apply updated_at trigger to all tables with updated_at column
CREATE TRIGGER set_products_updated_at
  BEFORE UPDATE ON public.products
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER set_orders_updated_at
  BEFORE UPDATE ON public.orders
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

-- Audit triggers
CREATE TRIGGER audit_products
  AFTER INSERT OR UPDATE OR DELETE ON public.products
  FOR EACH ROW EXECUTE FUNCTION public.audit_changes();
```

### RLS Policies Migration (00004)

```sql
-- supabase/migrations/00004_rls_policies.sql

-- Enable RLS on all tables
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;

-- Organization-based multi-tenancy (efficient with JWT claims)
CREATE POLICY "Org members can view products"
  ON public.products FOR SELECT
  USING (org_id = (SELECT auth.jwt() ->> 'org_id')::uuid);

CREATE POLICY "Org members can insert products"
  ON public.products FOR INSERT
  WITH CHECK (org_id = (SELECT auth.jwt() ->> 'org_id')::uuid);

CREATE POLICY "Org members can update products"
  ON public.products FOR UPDATE
  USING (org_id = (SELECT auth.jwt() ->> 'org_id')::uuid);

-- Performance indexes for RLS columns
CREATE INDEX IF NOT EXISTS idx_products_org_id ON public.products(org_id);
CREATE INDEX IF NOT EXISTS idx_orders_org_id ON public.orders(org_id);
```

---

## Migration Numbering Convention

```
supabase/migrations/
├── 00000_extensions.sql              # Always first
├── 00001_initial_tables.sql          # Shared base tables
├── 00002_core_functions.sql          # Shared functions
├── 00003_core_triggers.sql           # Shared triggers
├── 00004_base_rls.sql                # Initial RLS
│
├── 00100_drizzle_feature_a.sql       # TypeScript service (100s)
├── 00101_feature_a_functions.sql
├── 00102_feature_a_rls.sql
│
├── 00200_alembic_feature_b.sql       # Python service (200s)
├── 00201_feature_b_functions.sql
├── 00202_feature_b_rls.sql
│
├── 00300_sqlx_feature_c.sql          # Rust service (300s)
├── 00301_feature_c_functions.sql
├── 00302_feature_c_rls.sql
│
└── 00400_shared_functions.sql        # Cross-service (400s+)
```

**Number Ranges:**
- `00000-00099`: Bootstrap (extensions, core functions, base RLS)
- `00100-00199`: TypeScript/Node.js service migrations
- `00200-00299`: Python service migrations
- `00300-00399`: Rust service migrations
- `00400+`: Shared cross-service features

**Within each range, use offsets:**
- `XX00`: Table definitions (from ORM)
- `XX01`: Functions for this feature
- `XX02`: Triggers for this feature
- `XX03`: RLS for this feature

---

## ORM Detection in .kodo/config.json

The hybrid workflow is detected by checking:

```json
{
  "stack": {
    "workspaces": {
      "<workspace-name>": {
        "database": {
          "orm": {
            "name": "drizzle|sqlalchemy|sqlx|null",
            "migrationTool": "drizzle-kit|alembic|sqlx-cli|null"
          },
          "migrationStrategy": {
            "type": "hybrid|supabase-only"
          }
        }
      }
    }
  }
}
```

| ORM Name | Migration Tool | Language | Workflow |
|----------|---------------|----------|----------|
| `drizzle` | `drizzle-kit` | TypeScript | Hybrid |
| `sqlalchemy` | `alembic` | Python | Hybrid |
| `sqlx` | `sqlx-cli` | Rust | Hybrid |
| `null` | `null` | Any | Supabase-only |

---

## Type Generation by Language

### TypeScript (Drizzle)
```bash
# Drizzle types: automatic from schema.ts at compile time
# Supabase types: for RPC calls
supabase gen types typescript --local > src/types/supabase.ts
```

### Python (SQLAlchemy)
```bash
# SQLAlchemy types: from models.py (type hints + Pydantic)
# Supabase types: not natively supported, use raw SQL types
```

```python
# Use Pydantic for validation/serialization
from pydantic import BaseModel
from uuid import UUID
from decimal import Decimal

class ProductCreate(BaseModel):
    org_id: UUID
    name: str
    price: Decimal

class ProductResponse(BaseModel):
    id: UUID
    org_id: UUID
    name: str
    price: Decimal

    class Config:
        from_attributes = True
```

### Rust (SQLx)
```bash
# SQLx: compile-time type checking via sqlx-cli
# Prepare offline mode for CI
cargo sqlx prepare
```

```rust
// Types are checked at compile time with sqlx::query_as!
let product = sqlx::query_as!(
    Product,
    "SELECT * FROM products WHERE id = $1",
    id
)
.fetch_one(&pool)
.await?;
```

---

## Deployment Workflow

### CI/CD Pipeline (Multi-Service)

```yaml
# .github/workflows/db-deploy.yml
name: Database Deploy

on:
  push:
    branches: [main]
    paths:
      - 'supabase/migrations/**'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1

      - name: Apply all migrations atomically
        run: |
          supabase link --project-ref ${{ secrets.SUPABASE_PROJECT_REF }}
          supabase db push
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
```

### Local Development

```bash
# Start Supabase
supabase start

# Sync ORM migrations (language-specific)
# TypeScript:
npx drizzle-kit generate && cp drizzle/migrations/*.sql supabase/migrations/

# Python:
alembic revision --autogenerate -m "changes" && cp alembic/versions/*.sql supabase/migrations/

# Rust:
sqlx migrate add feature && cp migrations/*.sql supabase/migrations/

# Apply all
supabase db reset

# Generate types (TypeScript only)
supabase gen types typescript --local > src/types/supabase.ts
```

---

## Summary: What Goes Where

| Feature | ORM Layer (any language) | Supabase Layer |
|---------|-------------------------|----------------|
| Table structure | ✅ Schema files | Copy generated |
| Column types | ✅ Schema files | Copy generated |
| Foreign keys | ✅ Schema files | Copy generated |
| Indexes | ✅ Schema files | Copy generated |
| Extensions | ❌ | ✅ SQL migrations |
| Functions | ❌ | ✅ SQL migrations |
| Triggers | ❌ | ✅ SQL migrations |
| RLS Policies | ❌ | ✅ SQL migrations |
| Custom types | ⚠️ Use after created | ✅ SQL migrations |

**The Universal Rule**: ORMs handle data structure, Supabase handles data behavior.
